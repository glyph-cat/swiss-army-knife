// What this base script does:
// Crawl through each subfolder then automatically export everything
// from those subfolders to 'index.scripted.ts'.

import chalk from 'chalk'
import { readdirSync, readFileSync, statSync, writeFileSync } from 'fs'
import { DateTime } from 'luxon'
import path from 'path'
import { Encoding } from '../../../src/packages/foundation/src/encoding'

export function autoForwardExports(entryPath: string): void {

  const now = DateTime.now()
  const directoriesWithMissingIndexFiles: Array<string> = []

  const indexPattern = /\/index\.ts$/
  const ignorePattern = /\.(draft|old|scripted|secret)\.?/
  const exportScriptedSyntaxPattern = /export \* from '\.\/index\.scripted'/

  crawl(entryPath, (filePath) => {

    // #region Filtering
    if (!indexPattern.test(filePath)) { return }
    if (ignorePattern.test(filePath)) { return }
    const fileContents = readFileSync(filePath, Encoding.UTF_8)
    if (!exportScriptedSyntaxPattern.test(fileContents)) { return }
    // #endregion Filtering

    // #region Get directory contents
    const directoryPath = filePath.replace(indexPattern, '')
    const items = readdirSync(directoryPath).filter((item) => {
      return !ignorePattern.test(item) && !/^\./.test(item) && !/^index\./.test(item)
    })
    // #endregion Get directory contents

    // #region Writing scripted output
    console.log(`${chalk.cyan(`(${items.length})`)} ${directoryPath}`)
    const codeLineStack = [
      '// Please do not edit here.',
      '// This file was automatically generated by the script `yarn afe`.',
      '// To learn more, refer to `tools/auto-forward-exports`',
      '// in the project root directory.',
      '',
    ]
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
      const item = items[itemIndex]
      const connector = itemIndex >= items.length - 1 ? '└' : '├'
      if (/internal/i.test(item)) {
        console.log(chalk.gray(` ${connector} ${chalk.yellow(`# ${item} (skipped)`)}`))
        continue
      }
      const subPath = path.join(directoryPath, item)
      const itemIsDirectory = statSync(subPath).isDirectory()
      const hasIndexFile = itemIsDirectory
        ? checkIndexFile(subPath)
        : true // self is the '.ts' file already
      if (!hasIndexFile) { directoriesWithMissingIndexFiles.push(subPath) }
      const indicator = hasIndexFile ? chalk.green('✓') : chalk.red('×')
      const shouldForwardOnlyPublicExports = FILES_WITH_INTERNAL_AND_PUBLIC_EXPORTS.has(item) && (hasIndexFile && hasInternalAndPublicExports(path.join(subPath, 'index.ts')))
      console.log(chalk.gray(` ${connector} ${indicator} ${hasIndexFile
        ? item + (shouldForwardOnlyPublicExports ? chalk.cyan.dim('/public') : '')
        : chalk.red(`${item} (missing index file)`)}`
      ))
      if (shouldForwardOnlyPublicExports) {
        codeLineStack.push(`export * from './${item}/public'`)
      } else {
        codeLineStack.push(`export * from './${itemIsDirectory ? item : item.replace(/\.(j|t)sx?$/, '')}'`)
      }
    }
    if (items.length <= 0) {
      console.log(chalk.yellow(' └ ? Found no files to export'))
      codeLineStack.push('export {} // Found no files to export')
    }

    codeLineStack.push(`\n// Generated on: ${now.toSQL()}.`)

    writeFileSync(
      path.join(directoryPath, 'index.scripted.ts'),
      codeLineStack.join('\n') + '\n',
      Encoding.UTF_8,
    )
    // #endregion Writing scripted output

  })

  if (directoriesWithMissingIndexFiles.length > 0) {
    console.log(chalk.redBright('\nThese directories are missing index files:\n  ' + directoriesWithMissingIndexFiles.join('\n  ')) + '\n')
    process.exit(1)
  }

}

function crawl(dirPath: string, callback: (filePath: string) => void) {
  const allItemsInDir = readdirSync(dirPath)
  for (const item of allItemsInDir) {
    const nextPath = path.join(dirPath, item)
    if (statSync(nextPath).isDirectory()) {
      crawl(nextPath, callback)
    } else {
      callback(nextPath)
    }
  }
}

function checkIndexFile(directoryPath: string): boolean {
  const items = readdirSync(directoryPath)
  return !!items.find((item) => /^index\.tsx?$/.test(item))
}

const FILES_WITH_INTERNAL_AND_PUBLIC_EXPORTS = new Set([
  'abstractions',
  'constants',
  'utils',
])
const REGEX_EXPORT_ALL_FROM_INTERNAL = /export\s+\*\s+from\s+'\.\/internal'/
const REGEX_EXPORT_ALL_FROM_PUBLIC = /export\s+\*\s+from\s+'\.\/public'/

function hasInternalAndPublicExports(pathToFile: string): boolean {
  const fileContents = readFileSync(pathToFile, Encoding.UTF_8)
  return REGEX_EXPORT_ALL_FROM_INTERNAL.test(fileContents) &&
    REGEX_EXPORT_ALL_FROM_PUBLIC.test(fileContents)
}
