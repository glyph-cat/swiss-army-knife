import { Encoding } from '@glyph-cat/swiss-army-knife'
import chalk from 'chalk'
import { readdirSync, readFileSync, statSync, writeFileSync } from 'fs'

// export interface AutoForwardExportsOptions {
//   /**
//    * @defaultValue `'index.scripted.ts'`
//    */
//   outputFile?: string
//   /**
//    * @defaultValue `[/\.(draft|old|scripted|secret)\.?/]`
//    */
//   ignorePatterns?: Array<RegExp>
// }

// const DEFAULT_AUTO_FORWARD_EXPORTS_OPTIONS: Required<AutoForwardExportsOptions> = {
//   outputFile: 'index.scripted.ts',
//   ignorePatterns: [/\.(draft|old|scripted|secret)\.?/],
// }

/**
 * Crawls through each folder recursively then automatically export everything
 * from those subfolders to `'index.scripted.ts'`.
 * @public
 */
export function autoForwardExports(entryPath: string): void {

  // options = { ...DEFAULT_AUTO_FORWARD_EXPORTS_OPTIONS, ...options }
  // const { outputFile: outputFile, ignorePatterns } = options

  const now = new Date()
  const directoriesWithMissingIndexFiles: Array<string> = []

  crawl(entryPath, (filePath: string) => {

    // #region Filtering
    const indexPattern = /\/index\.ts$/
    if (!indexPattern.test(filePath)) { return }
    const ignorePattern = /\.(draft|old|scripted|secret)\.?/
    if (ignorePattern.test(filePath)) { return }
    const fileContents = readFileSync(filePath, Encoding.UTF_8)
    if (!/export \* from '\.\/index\.scripted'/.test(fileContents)) { return }
    // #endregion Filtering

    // #region Get directory contents
    const directoryPath = filePath.replace(indexPattern, '')
    const items = readdirSync(directoryPath).filter((item) => {
      return !ignorePattern.test(item) && !/^\./.test(item) && !/^index\./.test(item)
    })
    // #endregion Get directory contents

    // #region Writing scripted output
    console.log(`${chalk.cyan(`(${items.length})`)} ${directoryPath}`)
    const codeLineStack = [
      '// Please do not edit here.',
      '// This file was automatically generated by the script `yarn afe`.',
      '// To learn more, refer to `tools/auto-forward-exports`',
      '// in the project root directory.',
      '',
    ]
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
      const item = items[itemIndex]
      const connector = itemIndex >= items.length - 1 ? '└' : '├'
      if (/internal/i.test(item)) {
        console.log(chalk.gray(` ${connector} ${chalk.yellow(`# ${item} (skipped)`)}`))
        continue
      }
      const subPath = `${directoryPath}/${item}`
      const itemIsDirectory = statSync(subPath).isDirectory()
      const hasIndexFile = itemIsDirectory
        ? checkIndexFile(subPath)
        : true // self is the '.ts' file already
      if (!hasIndexFile) { directoriesWithMissingIndexFiles.push(subPath) }
      const indicator = hasIndexFile ? chalk.green('✓') : chalk.red('×')
      const isAbstractionsOrConstants = item === 'abstractions' || item === 'constants'
      console.log(chalk.gray(` ${connector} ${indicator} ${hasIndexFile
        ? item + (isAbstractionsOrConstants ? chalk.cyan.dim('/public') : '')
        : chalk.red(`${item} (missing index file)`)}`
      ))
      if (isAbstractionsOrConstants) {
        codeLineStack.push(`export * from './${item}/public'`)
      } else {
        codeLineStack.push(`export * from './${itemIsDirectory ? item : item.replace(/\.(j|t)sx?$/, '')}'`)
      }
    }
    if (items.length <= 0) {
      console.log(chalk.yellow(' └ ? Found no files to export'))
      codeLineStack.push('export {} // Found no files to export')
    }
    codeLineStack.push(
      `\n// Generated on: ${now.toDateString()} ${now.toTimeString().match(/\d{2}:\d{2}:\d{2} [a-z]+\+\d{4}/i)[0]}.`,
    )
    writeFileSync(
      `${directoryPath}/index.scripted.ts`,
      codeLineStack.join('\n') + '\n',
      Encoding.UTF_8,
    )
    // #endregion Writing scripted output

  })

  if (directoriesWithMissingIndexFiles.length > 0) {
    console.log(chalk.redBright('\nThese directories are missing index files:\n  ' + directoriesWithMissingIndexFiles.join('\n  ')) + '\n')
    process.exit(1)
  }

}

function crawl(dirPath: string, callback: (filePath: string) => void) {

  const allItemsInDir = readdirSync(dirPath)
  for (const item of allItemsInDir) {
    const nextPath = `${dirPath}/${item}`
    if (statSync(nextPath).isDirectory()) {
      crawl(nextPath, callback)
    } else {
      callback(nextPath)
    }
  }

}

function checkIndexFile(directoryPath: string): boolean {
  const items = readdirSync(directoryPath)
  return !!items.find((item) => /^index\.tsx?$/.test(item))
}
